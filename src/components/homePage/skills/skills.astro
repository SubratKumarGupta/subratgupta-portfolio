---
import DemoThreejs from "./threejs/demoThreejs.astro";
---

<script src="//unpkg.com/3d-force-graph"></script>
<div class="skills">
  <div
    class="text-5xl mobile:text-4xl mobile:h-[30vh] h-[50vh] flex flex-col justify-center"
  >
    <div class="ml-12 mobile:ml-4 text-primary-teal">
      {"${"}<span class="text-white">What can i do</span>{"}"}
    </div>
  </div>
  <div class="h-[100vh]">
    <DemoThreejs />
  </div>
  <div id="dottodot-parent" class="h-[150vh] w-full relative">
    <div id="3d-graph" style="height: 150vh;" class="h-[150vh]"></div>
    <!-- <div id="dottodot-line-parent" class="h-full w-full z-1 absolute"></div>
    <canvas id="dottodot" class="h-full w-full z-5 absolute"></canvas> -->

    <!-- <canvas id="" class="h-full w-full absolute"> </canvas> -->
  </div>
</div>
<style>
  .dottodot-backgound {
    height: 100%;
    width: 100%;
    background: #000;
    position: absolute;
  }
</style>

<script>
  import ForceGraph3D from "3d-force-graph";
  import { Mesh, MeshLambertMaterial, SphereGeometry, Vector2 } from "three";

  import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass";

  // Random tree
  const NODES = 1000;
  const GROUPS = 120;
  const gData = {
    nodes: [...Array(NODES).keys()].map((i) => ({
      id: i,
      group: Math.ceil(Math.random() * GROUPS),
    })),
    links: [...Array(NODES).keys()]
      .filter((id) => id)
      .map((id) => ({
        source: id,
        target: Math.round(Math.random() * (id - 1)),
      })),
  };
  const distance = 1400;
  const nodeMetrial = new MeshLambertMaterial({
    color: "#3fd4d4",
    emissive: "#3fd4d4",
    emissiveIntensity: 1,
    opacity: 1,
  });

  const getNodeMesh = () => {
    return new Mesh(new SphereGeometry(5), nodeMetrial);
  };

  const graphDiv = document.getElementById("3d-graph") as HTMLDivElement;
  const Graph = ForceGraph3D()(graphDiv)
    .nodeThreeObject(() => getNodeMesh())
    .linkOpacity(0.2)
    .showNavInfo(false)
    .zoomToFit()
    .enablePointerInteraction(false)
    .backgroundColor("#0e1212")
    .cameraPosition({ z: distance })
    .graphData(gData)
    .nodeColor((node) => "#3fd4d4");
  //@ts-ignore
  Graph.controls().noZoom = true;
  let angle = 0;
  let isPaused = false;
  let lastTime = 0;
  let cameraPosBeforePause = { x: 0, y: 0, z: 0 };
  const transitionDuration = 500; // in milliseconds

  const animate = (currentTime: number) => {
    const deltaTime = currentTime - lastTime;
    if (!isPaused) {
      Graph.cameraPosition({
        x: distance * Math.sin(angle),
        z: distance * Math.cos(angle),
      });
      angle += Math.PI / 300;
    } else {
      const timeSincePause = currentTime - lastTime;
      if (timeSincePause <= transitionDuration) {
        const t = timeSincePause / transitionDuration;
        const cameraPosX =
          cameraPosBeforePause.x +
          t * (distance * Math.sin(angle) - cameraPosBeforePause.x);
        const cameraPosZ =
          cameraPosBeforePause.z +
          t * (distance * Math.cos(angle) - cameraPosBeforePause.z);
        Graph.cameraPosition({
          x: cameraPosX,
          z: cameraPosZ,
        });
      }
    }
    lastTime = currentTime;
    requestAnimationFrame(animate);
  };

  const handleMouseDown = () => {
    isPaused = true;
    cameraPosBeforePause = Graph.cameraPosition();
  };

  const handleMouseUp = () => {
    isPaused = false;
    lastTime = performance.now();
  };

  document.addEventListener("mousedown", handleMouseDown);

  document.addEventListener("mouseup", handleMouseUp);

  requestAnimationFrame((currentTime) => {
    lastTime = currentTime;
    animate(currentTime);
  });

  // if

  // .nodeLabel("id")
  // .nodeAutoColorBy("group");
  // window.on

  // .nodeAutoColorBy("group");

  const res = new Vector2(graphDiv.clientWidth, graphDiv.clientHeight);
  const bloomPass = new UnrealBloomPass(res, 1, 1, 0.1);
  bloomPass.radius = 1;
  bloomPass.threshold = 0.1;

  // Graph.postProcessingComposer().addPass(bloomPass);
</script>
<!-- <script>
  import ForceGraph3D from "3d-force-graph";
  import { Vector2 } from "three";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass";

  import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass";

  // Random tree
  const NODES = 1000;
  const GROUPS = 120;
  const gData = {
    nodes: [...Array(NODES).keys()].map((i) => ({
      id: i,
      group: Math.ceil(Math.random() * GROUPS),
    })),
    links: [...Array(NODES).keys()]
      .filter((id) => id)
      .map((id) => ({
        source: id,
        target: Math.round(Math.random() * (id - 1)),
      })),
  };
  type link = {
    source: number;
    target: number;
  };
  type Data = {
    links?: link[];
    neighbors?: Data[];
    id: number;
    group: number;
  };
  gData.links.forEach((link) => {
    const a: Data = gData.nodes[link.source];
    const b: Data = gData.nodes[link.target];
    !a.neighbors && (a.neighbors = []);
    !b.neighbors && (b.neighbors = []);
    a.neighbors.push(b);
    b.neighbors.push(a);

    !a.links && (a.links = []);
    !b.links && (b.links = []);
    a.links.push(link);
    b.links.push(link);
  });

  const highlightNodes = new Set();
  const highlightLinks = new Set();
  let hoverNode: object | null = null;
  const graphDiv = document.getElementById("3d-graph") as HTMLDivElement;

  const Graph = ForceGraph3D()(graphDiv)
    .graphData(gData)
    .nodeColor((node) =>
      highlightNodes.has(node)
        ? node === hoverNode
          ? "rgb(255,0,0,1)"
          : "rgba(255,160,0,0.8)"
        : "rgba(0,255,255,0.6)"
    )
    .linkWidth((link) => (highlightLinks.has(link) ? 4 : 1))
    .linkDirectionalParticles((link) => (highlightLinks.has(link) ? 4 : 0))
    .linkDirectionalParticleWidth(4)
    .onNodeHover((node: any) => {
      // no state change
      if ((!node && !highlightNodes.size) || (node && hoverNode === node))
        return;

      highlightNodes.clear();
      highlightLinks.clear();

      if (node) {
        highlightNodes.add(node);
        node.neighbors.forEach((neighbor: any) => highlightNodes.add(neighbor));
        node.links.forEach((link: any) => highlightLinks.add(link));
      }

      hoverNode = node || null;

      updateHighlight();
    })

    .onLinkHover((link: any) => {
      highlightNodes.clear();
      highlightLinks.clear();

      if (link) {
        highlightLinks.add(link);
        highlightNodes.add(link.source);
        highlightNodes.add(link.target);
      }

      updateHighlight();
    });

  function updateHighlight() {
    // trigger update of highlighted objects in scene
    Graph.nodeColor(Graph.nodeColor())
      // .backgroundColor("rgba(0,0,0,0")
      .linkWidth(Graph.linkWidth())
      .linkDirectionalParticles(Graph.linkDirectionalParticles());
  }
</script> -->
<!-- <script>
  import gsap from "gsap";

  import type Index from "src/pages/index.astro";
  type CircleGridValue = {
    id: [number, number];
    pos: { X: number; Y: number };
    // paused: boolean ;
    // canPause: boolean ;
    instance: Circle | null;
  };
  type DrawLineOptions = {
    onStart?: () => void;
    onReach?: () => void;
    durationTypeSpeed: boolean;
    duration: number;
    speed: number;
    // onComplete?: () => void;
  };

  type Address = { Row: number; Col: number };
  type GridSize = {
    Rows: number;
    Cols: number;
  };
  function calculateDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): number {
    const xDiff = x2 - x1;
    const yDiff = y2 - y1;
    const distance = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
    return distance;
  }
  class Circle {
    private bgParent: HTMLDivElement;
    private canvas: HTMLCanvasElement;
    private context: CanvasRenderingContext2D;
    public readonly x: number;
    public readonly y: number;
    public readonly outerRadius: number;
    public readonly innerRadius: number;
    public readonly color: string;
    public readonly lineWidth: number;
    public readonly lineColor: string;
    timeline: gsap.core.Timeline;
    public readonly animateToRadius: number;
    constructor(
      bgParent: HTMLDivElement,
      canvas: HTMLCanvasElement,
      x: number,
      y: number,
      animateToRadius: number,
      outerRadius: number,
      innerRadius: number,
      color: string,
      lineWidth: number,
      lineColor: string,
      onComplete: () => void
      // to: [number, number]
    ) {
      (this.animateToRadius = animateToRadius), (this.canvas = canvas);
      this.bgParent = bgParent;
      this.context = canvas.getContext("2d")!;
      this.x = x;
      this.y = y;
      this.outerRadius = outerRadius;
      this.innerRadius = innerRadius;
      this.color = color;
      this.lineWidth = lineWidth;
      this.lineColor = lineColor;
      this.timeline = gsap.timeline({
        onStart: () => {
          this.context.clearRect(
            this.x - animateToRadius - this.lineWidth,
            this.y - animateToRadius - this.lineWidth,
            animateToRadius * 2 + this.lineWidth * 2,
            animateToRadius * 2 + this.lineWidth * 2
          );
        },
        onUpdate: () => {
          this.context.clearRect(
            this.x - animateToRadius - lineWidth,
            this.y - animateToRadius - lineWidth,
            animateToRadius * 2 + lineWidth * 2,
            animateToRadius * 2 + lineWidth * 2
          );
          this.draw();
        },
        onComplete: () => {
          // const lineWidth = 20;
          // this.context.clearRect(0, 0, 500, 500);
          this.context.clearRect(
            this.x - animateToRadius - this.lineWidth,
            this.y - animateToRadius - this.lineWidth,
            animateToRadius * 2 + this.lineWidth * 2,
            animateToRadius * 2 + this.lineWidth * 2
          );
          onComplete();
        },
      });
      this.animate(animateToRadius);
    }
    public RequstShot(from: CircleGridValue, options: DrawLineOptions) {
      if (from.instance === null) {
        throw new Error(`Failed to RequstShot : no instance at ${from.id} `);
      }
      from.instance.drawLineTo([this.x, this.y], {
        onReach: options.onReach,
        onStart: options.onStart,
        durationTypeSpeed: options.durationTypeSpeed,
        duration: options.duration,
        speed: options.speed,
      });
    }
    public shoot(at: CircleGridValue, options: DrawLineOptions) {
      if (at.instance!) {
        throw new Error(`Failed to shoot : no instance at ${at.id}`);
      }
      console.log("sooting at", at);
      this.drawLineTo([at.pos.X, at.pos.Y], {
        onReach: options.onReach,
        onStart: options.onStart,
        durationTypeSpeed: options.durationTypeSpeed,
        duration: options.duration,
        speed: options.speed,
      });
    }
    public GotShot(runAfterPuse: () => void) {
      console.log("ab");
      this.timeline.pause();
      runAfterPuse();
    }
    private animate(to: number) {
      this.timeline
        .to(this, {
          duration: 0.5,
          outerRadius: (50 / 100) * ((75 / 100) * to),
        })
        .to(this, {
          duration: 1,
          outerRadius: (75 / 100) * to,
        })
        .to(this, {
          duration: 1.5,
          outerRadius: to,
          innerRadius: to,
          lineWidth: 3,
        });
    }

    private drawLineTo(to: [number, number], options: DrawLineOptions) {
      const canvas = document.createElement("canvas") as HTMLCanvasElement; // create a new canvas element
      canvas.classList.add("dottodot-background"); // add the "dottodot-background" class to the canvas
      canvas.height = this.canvas.clientHeight; // set the canvas height to 100%
      canvas.width = this.canvas.clientWidth; // set the canvas width to 100%
      canvas.style.position = "absolute";
      // canvas.style.zIndex = "1"; // set the canvas z-index to 5
      this.bgParent.appendChild(canvas); // append the canvas
      const lineContext = canvas.getContext("2d")!;

      type Line = {
        XStart: number;
        YStart: number;
        XEnd: number;
        YEnd: number;
      };

      const line: Line = {
        XStart: this.x,
        YStart: this.y,
        XEnd: this.x,
        YEnd: this.y,
      };
      const dist = calculateDistance(this.x, this.y, to[0], to[1]);
      const lineWidth = 1;
      const lineColor = "#ffffff";
      const speed = options.speed;
      const draw = (lineContext: CanvasRenderingContext2D) => {
        lineContext.beginPath();
        lineContext.moveTo(line.XStart, line.YStart);
        lineContext.lineTo(line.XEnd, line.YEnd);
        lineContext.stroke();
        lineContext.lineWidth = lineWidth;
        lineContext.strokeStyle = lineColor;
        lineContext.closePath();
      };
      const duration = options.durationTypeSpeed
        ? dist / speed
        : options.duration;
      const Drawline = gsap.timeline({
        onStart: () => {
          if (options.onStart) {
            options.onStart();
          }
        },
        onUpdate: () => {
          draw(lineContext);
        },
        onComplete: () => {
          canvas.remove();

          // this.bgcontext.globalCompositeOperation = "source-over";
        },
      });
      Drawline.to(line, {
        onComplete: () => {
          if (options.onReach) {
            options.onReach();
          }
          // if (dist !== calculateDistance(line.XStart, line.YStart, to[0], to[1])) {return}
        },
        duration: duration, // dist / speed,
        XEnd: to[0],
        YEnd: to[1],
      }).to(line, {
        onStart: () => {},
        onUpdate: () => {
          lineContext.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        },
        duration: dist / speed, //,
        XStart: to[0],
        YStart: to[1],
      });
    }
    private draw() {
      // this.context.clearRect(0, 0, 500, 500);
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.outerRadius, 0, 2 * Math.PI);
      this.context.fillStyle = this.color;
      this.context.fill();
      this.context.lineWidth = this.lineWidth;
      this.context.strokeStyle = this.lineColor;
      this.context.closePath();

      this.context.stroke();
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.innerRadius, 0, 2 * Math.PI, true);
      this.context.fillStyle = this.lineColor;
      this.context.fill();
      this.context.closePath();
    }
  }
  const bgparent = document.getElementById(
    "dottodot-line-parent"
  ) as HTMLDivElement; // get the div element
  const canvas = document.getElementById("dottodot") as HTMLCanvasElement;
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  class CircleGrid {
    private static instance: CircleGrid;
    private grid: Map<string, CircleGridValue>;
    private onscreenInstances: Map<string, Circle>;

    private constructor(
      public readonly rows: number,
      public readonly cols: number,
      public readonly spacing: number
    ) {
      this.grid = new Map();
      this.onscreenInstances = new Map();
      this.spacing = spacing;
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          const key = this.getAddressKey(row, col);
          const x = (col + 0.5) * spacing;
          const y = (row + 0.5) * spacing;
          this.grid.set(key, {
            id: [col, row],
            pos: { X: x, Y: y },
            instance: null,
          });
        }
      }
    }

    public static getInstance(
      rows: number,
      cols: number,
      spacing: number
    ): CircleGrid {
      if (!CircleGrid.instance) {
        CircleGrid.instance = new CircleGrid(rows, cols, spacing);
      }
      return CircleGrid.instance;
    }

    public getValue(row: number, col: number): CircleGridValue {
      const key = this.getAddressKey(row, col);
      const gridValue = this.grid.get(key);
      if (!gridValue) {
        throw new Error(`No value found at address: Row ${row}, Col ${col}`);
      }
      return gridValue;
    }

    public setValue(row: number, col: number, value: CircleGridValue): void {
      const key = this.getAddressKey(row, col);
      this.grid.set(key, value);
    }

    public getRandomAddress(): { Row: number; Col: number } {
      const randomRow = Math.floor(Math.random() * this.rows);
      const randomCol = Math.floor(Math.random() * this.cols);
      return { Row: randomRow, Col: randomCol };
    }

    public addOnscreenInstance(
      row: number,
      col: number,
      instance: Circle
    ): void {
      const key = this.getAddressKey(row, col);
      this.onscreenInstances.set(key, instance);
    }

    public removeOnscreenInstance(row: number, col: number): void {
      const key = this.getAddressKey(row, col);
      this.onscreenInstances.delete(key);
    }

    public getOnscreenInstance(row: number, col: number): Circle | undefined {
      const key = this.getAddressKey(row, col);
      return this.onscreenInstances.get(key);
    }
    public getRandomOnscreenInstance():
      | { row: number; col: number; circle: Circle | undefined }
      | undefined {
      if (this.onscreenInstances.size > 0) {
        const keys = Array.from(this.onscreenInstances.keys());
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        const circle = this.onscreenInstances.get(randomKey);
        if (circle) {
          const [col, row] = randomKey.split(",").map(Number);
          return { row, col, circle };
        }
      }
      return undefined;
    }

    private getAddressKey(row: number, col: number): string {
      return `${row},${col}`;
    }
  }

  const getRandomExcept = (
    input: number,
    maxlimit: number,
    exclude: number,
    rangePercent: number,
    maxAttempts: number = 50
  ): number => {
    if (!Number.isFinite(rangePercent) || rangePercent < 0) {
      throw new Error(
        "Invalid input: rangePercent must be a number greater than 0."
      );
    }

    if (maxAttempts < 1) {
      throw new Error("Invalid input: maxAttempts must be a positive integer.");
    }

    let range: number = 3;
    if (rangePercent > 1) {
      range = rangePercent;
    } else {
      range = Math.floor(maxlimit * rangePercent);
    }

    const lowerLimit = Math.max(0, input - range);
    const upperLimit = Math.min(maxlimit - 1, input + range);
    const rangeSize = upperLimit - lowerLimit + 1;

    let randNum: number | null = null;
    let attempts = 0;
    const randomFactor = Math.random() > 0.5 ? 1 : -1;
    let offset = randomFactor * Math.ceil(rangeSize / 2);

    do {
      randNum = Math.floor(Math.random() * rangeSize) + lowerLimit;
      attempts++;
    } while (
      (randNum === input || randNum === exclude) &&
      attempts < maxAttempts
    );

    if (attempts === maxAttempts && randNum === null) {
      if (randNum === null) {
        console.log("nill", randNum);
      }
      throw new Error(
        `Failed to generate a valid random number after ${maxAttempts} attempts, input ${input}, range ${rangePercent}, maxlimit ${maxlimit}.`
      );
    }

    return randNum;
  };

  const getForwardDiagonalLength = (
    rows: number,
    cols: number,
    cellAddress: Address
  ): number => {
    const minDimension = Math.min(rows, cols);
    let diagonalLength = 0;

    if (cellAddress.Row <= cellAddress.Col) {
      diagonalLength = Math.min(
        minDimension,
        cols - cellAddress.Col + cellAddress.Row
      );
    } else {
      diagonalLength = Math.min(
        minDimension,
        rows - cellAddress.Row + cellAddress.Col
      );
    }

    return diagonalLength - 1;
  };
  const randomZeroOrOne = () => {
    return Math.round(Math.random());
  };
  const randNum = (min: number, max: number) => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  const getBackwardDiagonalLength = (
    rows: number,
    cols: number,
    cellAddress: Address
  ): number => {
    const minDimension = Math.min(rows, cols);
    let diagonalLength = 0;

    // Determine the length of the diagonal based on the position of the cell within the grid.
    if (cellAddress.Row + cellAddress.Col >= cols) {
      diagonalLength = Math.min(
        minDimension,
        cols - cellAddress.Col + rows - cellAddress.Row
      );
    } else {
      diagonalLength = Math.min(
        minDimension,
        cellAddress.Row + cellAddress.Col + 1
      );
    }

    return diagonalLength - 1;
  };
  const calculateDiagonalCellCol = (
    origin: Address,
    gridSize: GridSize,
    diagonalRow: number,
    mode: "Forward" | "Backward"
  ): number => {
    if (
      !origin ||
      typeof origin.Row !== "number" ||
      typeof origin.Col !== "number"
    ) {
      throw new Error("Invalid origin address");
    }
    if (
      origin.Row < 0 ||
      origin.Row >= gridSize.Rows ||
      origin.Col < 0 ||
      origin.Col >= gridSize.Cols
    ) {
      throw new Error(
        `Invalid origin "col:"${origin.Col} row:${origin.Row} address: out of bounds`
      );
    }

    if (
      !gridSize ||
      typeof gridSize.Rows !== "number" ||
      typeof gridSize.Cols !== "number"
    ) {
      throw new Error("Invalid grid size");
    }

    if (
      typeof diagonalRow !== "number" ||
      diagonalRow < 0 ||
      diagonalRow >= gridSize.Rows
    ) {
      throw new Error("Invalid diagonal row index");
    }

    if (mode !== "Forward" && mode !== "Backward") {
      throw new Error("Invalid mode");
    }

    const rowDiff = origin.Row - diagonalRow;

    let otherCellCol: number = 0;
    if (mode === "Forward") {
      otherCellCol = origin.Col - rowDiff;
    } else if (mode === "Backward") {
      otherCellCol = origin.Col + rowDiff;
    } else {
      throw new Error(`Invalid mode: ${mode}`);
    }

    if (otherCellCol < 0 || otherCellCol >= gridSize.Cols) {
      // throw new Error(
      //   `Error: calculated column value is out of bounds,
      //   ${otherCellCol}
      //   ${gridSize.Rows},
      //   ${origin.Row >= gridSize.Rows},
      //   ${{ origin, diagonalRow }}`
      // );
    }

    return otherCellCol;
  };

  function drawCircleGrid(
    bgparent: HTMLDivElement,
    canvas: HTMLCanvasElement,
    spacing: number,
    outerRadius: number,
    innerRadius: number,
    color: string,
    lineWidth: number,
    lineColor: string
  ) {
    const numCols = Math.floor(canvas.width / spacing);
    const numRows = Math.floor(canvas.height / spacing);
    const circleGrid = CircleGrid.getInstance(numRows, numCols, spacing);

    const genrateRandomAddress = (range: number, address: Address): Address => {
      const getRandomAddressOnForwordDigonal = (): Address => {
        const forwardDiagonalLength = getForwardDiagonalLength(
          circleGrid.rows,
          circleGrid.cols,
          address
        );
        const maxRow = Math.min(
          circleGrid.rows - 1,
          address.Row + range,
          address.Row + forwardDiagonalLength - 1
        );
        const newRow = getRandomExcept(address.Row, maxRow, 0, range);
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            address,
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            newRow,
            "Forward"
          ),
        };
        console.log(newAddress, "newAddress");
        return newAddress;
      };
      const getRandomAddressOnBackwordsDigonal = (): Address => {
        const backwardDiagonalLength = getBackwardDiagonalLength(
          circleGrid.rows,
          circleGrid.cols,
          address
        );
        const maxRow = Math.min(
          circleGrid.rows - 1,
          address.Row + range,
          circleGrid.rows - 1 - backwardDiagonalLength + address.Row
        );
        const newRow = getRandomExcept(address.Row, maxRow, address.Row, range);
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            { Row: newRow, Col: address.Col },
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            circleGrid.rows - 1 - newRow,
            "Backward"
          ),
        };
        return newAddress;
      };

      // Generate a random address based on the given range and the current address

      // perpendicular
      if (randomZeroOrOne()) {
        return randomZeroOrOne()
          ? {
              Row: address.Row,
              Col: getRandomExcept(
                address.Col,
                circleGrid.cols, //Math.min(500, ),
                address.Col,
                range
              ),
            }
          : {
              Row: getRandomExcept(
                address.Row,
                circleGrid.rows, //Math.min(500, circleGrid.rows - 1),
                address.Row,
                range
              ),
              Col: address.Col,
            };
      } else {
        return randomZeroOrOne()
          ? getRandomAddressOnForwordDigonal()
          : getRandomAddressOnBackwordsDigonal();
      }
    };
    const createCircleInstance = (
      bgparent: HTMLDivElement,
      canvas: HTMLCanvasElement,
      position: { X: number; Y: number },
      onComplete: () => void
    ) => {
      return new Circle(
        bgparent,
        canvas,
        position.X,
        position.Y,
        randNum(15, 25),
        outerRadius,
        innerRadius,
        color,
        lineWidth,
        lineColor,
        onComplete
      );
    };
    const createCircleGridValue = (
      CircleAddress: Address,
      listOfAddress: readonly Address[],
      afterCreation:
        | ((
            createdCircleInstance: Circle,
            address: Address,
            listOfAddress: readonly Address[]
          ) => void)
        | null
    ) => {
      const position = circleGrid.getValue(
        CircleAddress.Row,
        CircleAddress.Col
      ).pos;

      const CircleInstance = createCircleInstance(
        bgparent,
        canvas,
        position,
        () => {
          console.log("oaoa");
          circleGrid.removeOnscreenInstance(
            CircleAddress.Row,
            CircleAddress.Col
          );
          circleGrid.setValue(CircleAddress.Row, CircleAddress.Col, {
            id: [CircleAddress.Col, CircleAddress.Row],
            pos: position,
            instance: null,
          });
        }
      );
      // CircleInstance.timeline.eventCallback("onComplete", () => {
      //
      // });
      circleGrid.setValue(CircleAddress.Row, CircleAddress.Col, {
        id: [CircleAddress.Col, CircleAddress.Row],
        pos: position,
        instance: CircleInstance,
      });

      const gridValue = circleGrid.getValue(
        CircleAddress.Row,
        CircleAddress.Col
      );

      if (gridValue.instance === null) {
        throw new Error(
          `failed to create a circle on ${gridValue} at ${gridValue.id}`
        );
      }
      {
        console.log(`created circle at${gridValue.id} `);
      }

      if (afterCreation) {
        (() => {
          if (gridValue.instance)
            afterCreation(gridValue.instance, CircleAddress, listOfAddress);
        })();
      }
      // return
    };
    const generateListOfRandomAddress = (
      howMany: number,
      range: number,
      firstAddress: Address
    ) => {
      const listOfRandomAddress: Address[] = [];
      console.log(firstAddress, "firstAddress");
      listOfRandomAddress.push(firstAddress);

      const maxAttempts = 100; // set the maximum number of attempts
      let attemptCount = 0; // initialize the counter
      console.log("max");
      function isCellOutOfBounds(cell: Address, gridSize: GridSize): boolean {
        return (
          cell.Row < 0 ||
          cell.Row >= gridSize.Rows ||
          cell.Col < 0 ||
          cell.Col >= gridSize.Cols
        );
      }

      let validAddressGenerated = false;
      while (listOfRandomAddress.length < howMany) {
        validAddressGenerated = false;
        attemptCount++;
        if (attemptCount === maxAttempts) {
          const a = {
            fr: listOfRandomAddress[0].Row,
            fc: listOfRandomAddress[0].Col,
            lr: listOfRandomAddress[listOfRandomAddress.length - 1].Row,
            lc: listOfRandomAddress[listOfRandomAddress.length - 1].Col,
          };
          throw new Error(
            `Failed to generate ${howMany} random addresses within ${maxAttempts} attempts. Maximum attempts reached current array is ${[
              a.fc,
              a.fc,
              a.lr,
              a.lc,
            ]}.`
          );
        }
        const newAddress = genrateRandomAddress(
          range,
          listOfRandomAddress[listOfRandomAddress.length - 1]
        );
        const doesAddressAlreadyExist = listOfRandomAddress.some(
          (addr) => addr.Col === newAddress.Col && addr.Row === newAddress.Row
        );
        const outOfBounds = isCellOutOfBounds(newAddress, {
          Rows: circleGrid.rows,
          Cols: circleGrid.cols,
        });
        if (doesAddressAlreadyExist || outOfBounds) {
          continue;
        }

        const doseInstancAlreadyExist = (() => {
          const value = circleGrid.getValue(newAddress.Row, newAddress.Col);
          if (value.instance instanceof Circle) {
            return true;
          }
          return false;
        })();
        if (doseInstancAlreadyExist) continue;

        validAddressGenerated = true;
        listOfRandomAddress.push(newAddress);
      }

      return listOfRandomAddress;
    };

    function findNearestCircleInRange(
      range: number,
      address: Address,
      circleGrid: CircleGrid
    ): CircleGridValue | null {
      const { rows, cols } = circleGrid;

      // Check if the given address is within the grid
      if (
        address.Row < 0 ||
        address.Row >= rows ||
        address.Col < 0 ||
        address.Col >= cols
      ) {
        return null;
      }

      // Check the neighboring cells for a circle within range
      for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
          // Skip the current cell (i=0, j=0)
          if (i === 0 && j === 0) {
            continue;
          }

          // Check if the neighboring cell is within the grid
          const row = address.Row + i;
          const col = address.Col + j;
          if (row < 0 || row >= rows || col < 0 || col >= cols) {
            continue;
          }

          // Check if the neighboring cell has a Circle instance and is within range
          const neighbor = circleGrid.getValue(row, col);
          if (
            !(neighbor.instance instanceof Circle) ||
            Math.abs(i) > range ||
            Math.abs(j) > range
          ) {
            continue;
          }

          // Check if the neighboring cell is diagonal or perpendicular to the given cell
          if ((i !== 0 && j !== 0) || i !== 0 || j !== 0) {
            return circleGrid.getValue(row, col);
            // return { Row: row, Col: col };
          }
        }
      }

      // No neighboring circle within range found
      return null;
    }

    const runGetRandomOnscreenInstance = (): void => {
      setInterval(() => {
        const onscreenInstances = circleGrid.getRandomOnscreenInstance();
        if (onscreenInstances === undefined) return;
        const { row, col, circle } = onscreenInstances;
        const AddressList = generateListOfRandomAddress(3, 3, {
          Row: row,
          Col: col,
        });
        const newCircleAddress = AddressList[1];
        if (circle === undefined) return;
        if (circleGrid.getValue(row, col).instance === null) return;
        createCircleGridValue(
          newCircleAddress,
          AddressList,
          (createdCircle) => {
            createdCircle.RequstShot(
              circleGrid.getValue(row, col), //newcircle
              {
                onReach: () => {
                  if (createdCircle.timeline.progress() === 0.9) return;
                  createdCircle.GotShot(() => {
                    try {
                      circleGrid.addOnscreenInstance(
                        newCircleAddress.Row,
                        newCircleAddress.Col,
                        createdCircle
                      );
                      console.log("brokaa");
                    } catch (error) {
                      console.log("brok", error);
                      return null;
                    }
                  });
                },
                speed: 100,
                duration: 0.4,
                durationTypeSpeed: true,
                onStart: () => {
                  circle.timeline.resume();
                },
              }
            );
            circle.timeline.resume();
          }
        );
        onscreenInstances;
      }, 500);
    };

    const ListOfRandomAddress = generateListOfRandomAddress(
      13,
      6,
      circleGrid.getRandomAddress()
    );
    console.log(ListOfRandomAddress, "a");
    const createInitialCircles = (AddressList: readonly Address[]) => {
      const seedCircleAddress = AddressList[0];
      let createdCircles = 0;
      const recursiveCreateInitalCircles = (Address: Address) => {
        console.log(createdCircles);
        if (createdCircles === AddressList.length) return;
        createCircleGridValue(
          Address,
          AddressList,
          (createdCircle, _, AddressList) => {
            createdCircles++;
            //for last circle in the list
            if (createdCircles === AddressList.length) return;
            if (AddressList === undefined) return;

            const nextAddress = AddressList[createdCircles];
            createdCircle.shoot(
              circleGrid.getValue(nextAddress.Row, nextAddress.Col),
              {
                onReach: () => {
                  console.log("abbbb", createdCircles);
                  recursiveCreateInitalCircles(nextAddress);
                  const newCreatedCircle = circleGrid.getValue(
                    nextAddress.Row,
                    nextAddress.Col
                  ).instance;
                  console.log(newCreatedCircle, "aut");
                  if (newCreatedCircle === null) return;
                  setTimeout(() => {
                    if (createdCircle.timeline.progress() === 0.9) return;
                    newCreatedCircle.GotShot(() => {
                      try {
                        circleGrid.addOnscreenInstance(
                          nextAddress.Row,
                          nextAddress.Col,
                          newCreatedCircle
                        );
                      } catch (error) {
                        console.log("brok", error);
                        return null;
                      }
                    });
                  }, 1500);
                },
                speed: 300,
                duration: 0.4,
                durationTypeSpeed: false,
                onStart: () => {},
              }
            );
          }
        );
      };
      recursiveCreateInitalCircles(seedCircleAddress);
    };
    //split array in tow
    const firstHalf = ListOfRandomAddress.slice(
      0,
      Math.floor(ListOfRandomAddress.length / 2)
    );
    const secondHalf = ListOfRandomAddress.slice(
      Math.floor(ListOfRandomAddress.length / 2)
    );
    //draw array seprately
    createInitialCircles(firstHalf);
    createInitialCircles(secondHalf);
    runGetRandomOnscreenInstance();

    // seedCircleInstance
    // ListOfRandomAddress.forEach((Address, i) => { // remove this
    //   console.log(Address, "r", circleGrid.rows, "c", circleGrid.cols);
    //   const position = circleGrid.getValue(Address.Row, Address.Col).pos;
    //   const prevCircal = circleGrid.getValue(
    //     ListOfRandomAddress[i + 1].Row,
    //     ListOfRandomAddress[i + 1].Col
    //   );
    //   const instance = new Circle(
    //     bgparent,
    //     canvas,
    //     position.X,
    //     position.Y,
    //     20,
    //     outerRadius,
    //     innerRadius,
    //     color,
    //     lineWidth,
    //     lineColor,
    //     300,
    //     [prevCircal.pos.X, prevCircal.pos.Y]
    //   );
    //   circleGrid.setValue(Address.Row, Address.Col, {
    //     id: [Address.Col, Address.Row],
    //     pos: {
    //       X: position.X,
    //       Y: position.Y,
    //     },
    //     instance: instance,
    //   });
    // });

    console.log(circleGrid);
  }

  window.addEventListener("resize", () => {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    const canvases = document.querySelectorAll(".dottodot-background"); // get all canvas elements with the "dottodot-background" class
    canvases.forEach((canvas) => {
      canvas.remove(); // remove each canvas element
    });
    drawCircleGrid(bgparent, canvas, 70, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
  });
  drawCircleGrid(bgparent, canvas, 70, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
</script> -->

<!-- given an  2d grid  with value type CircleGridValue = {
  id: [number, number];
  pos: { X: number; Y: number };
  // paused: boolean ;
  // canPause: boolean ;
  instance: Circle | null;
};  write a function in typescript that takes in a range value 'range', size of grid as type GridSize = {
  Rows: number;
  Cols: number;
}; , an address of a cell on the grid as 
type Address = { Row: number; Col: number }; and finds address of a grid

  const recursiveCreateCircles = (address: Address) => {
                          createCircleGridValue(
                            address,
                            [address],
                            (createdCircle) => {
                              const NextAddress = generateListOfRandomAddress(
                                3,
                                3,
                                address
                              )[1];
                              const nextCircle = circleGrid.getValue(
                                NextAddress.Row,
                                NextAddress.Col
                              );
                              createdCircle.shoot(nextCircle, {
                                onReach: () => {
                                  recursiveCreateCircles(NextAddress);
                                  setTimeout(() => {
                                    if (nextCircle.instance === null) return;
                                    nextCircle.instance.GotShot(
                                      () => {
                                        try {
                                          return generateListOfRandomAddress(
                                            3,
                                            3,
                                            address
                                          )[1];
                                        } catch (error) {
                                          console.log("brok");
                                          return null;
                                        }
                                      },
                                      (newaddress) => {
                                        console.log("a0a0a");
                                        recursiveCreateCircles(newaddress);
                                      }
                                    );
                                  }, 5000);
                                },
                                speed: 100,
                                duration: 1,
                                durationTypeSpeed: true,
                                onStart: () => {},
                              });
                            }
                          );
                        };
                        recursiveCreateCircles(address);

-->
