---
import DemoThreejs from "./threejs/demoThreejs.astro";
---

<div class="skills">
  <div
    class="text-5xl mobile:text-4xl mobile:h-[30vh] h-[50vh] flex flex-col justify-center"
  >
    <div class="ml-12 mobile:ml-4 text-primary-teal">
      {"${"}<span class="text-white">What can i do</span>{"}"}
    </div>
  </div>
  <div class="h-[100vh]">
    <DemoThreejs />
  </div>
  <div id="dottodot-parent" class="h-[100vh] relative">
    <div id="dottodot-line-parent" class="h-full w-full z-1 absolute"></div>
    <canvas id="dottodot" class="h-full w-full z-5 absolute"></canvas>

    <!-- <canvas id="" class="h-full w-full absolute"> </canvas> -->
  </div>
</div>
<style>
  .dottodot-backgound {
    height: 100%;
    width: 100%;
    background: #000;
    position: absolute;
  }
</style>
<script>
  import gsap from "gsap";
  class Circle {
    private bgParent: HTMLDivElement;
    private canvas: HTMLCanvasElement;
    private context: CanvasRenderingContext2D;
    public readonly x: number;
    public readonly y: number;
    public readonly outerRadius: number;
    public readonly innerRadius: number;
    public readonly color: string;
    public readonly lineWidth: number;
    public readonly lineColor: string;
    private timeline: gsap.core.Timeline;
    public readonly animateToRadius: number;
    constructor(
      bgParent: HTMLDivElement,
      canvas: HTMLCanvasElement,
      x: number,
      y: number,
      animateToRadius: number,
      outerRadius: number,
      innerRadius: number,
      color: string,
      lineWidth: number,
      lineColor: string,
      to: [number, number]
    ) {
      (this.animateToRadius = animateToRadius), (this.canvas = canvas);
      this.bgParent = bgParent;
      this.context = canvas.getContext("2d")!;
      this.x = x;
      this.y = y;
      this.outerRadius = outerRadius;
      this.innerRadius = innerRadius;
      this.color = color;
      this.lineWidth = lineWidth;
      this.lineColor = lineColor;
      this.timeline = gsap.timeline({
        repeat: -1,
        delay: 2,
        // repeatRefresh: true,
        onStart: () => {
          this.context.clearRect(
            this.x - animateToRadius - this.lineWidth,
            this.y - animateToRadius - this.lineWidth,
            animateToRadius * 2 + this.lineWidth * 2,
            animateToRadius * 2 + this.lineWidth * 2
          );
        },
        onUpdate: () => {
          this.context.clearRect(
            this.x - animateToRadius - lineWidth,
            this.y - animateToRadius - lineWidth,
            animateToRadius * 2 + lineWidth * 2,
            animateToRadius * 2 + lineWidth * 2
          );
          this.draw();
        },
        onComplete: () => {
          // const lineWidth = 20;
          this.context.clearRect(
            this.x - animateToRadius - lineWidth,
            this.y - animateToRadius - lineWidth,
            animateToRadius * 2 + lineWidth * 2,
            animateToRadius * 2 + lineWidth * 2
          );
        },
      });
      // this.draw();
      this.animate(animateToRadius);
      this.drawLineTo(to);
    }
    private animate(to: number) {
      this.timeline
        .to(this, {
          duration: 3,
          outerRadius: (75 / 100) * to,

          yoyo: true,
        })
        .to(this, {
          duration: 1.5,
          outerRadius: to,
          innerRadius: to,
          lineWidth: 0,
        });
    }
    public drawLineTo(to: [number, number]) {
      const canvas = document.createElement("canvas") as HTMLCanvasElement; // create a new canvas element
      canvas.classList.add("dottodot-background"); // add the "dottodot-background" class to the canvas
      canvas.height = this.canvas.clientHeight; // set the canvas height to 100%
      canvas.width = this.canvas.clientWidth; // set the canvas width to 100%
      canvas.style.position = "absolute";
      // canvas.style.zIndex = "1"; // set the canvas z-index to 5
      this.bgParent.appendChild(canvas); // append the canvas
      const lineContext = canvas.getContext("2d")!;

      type Line = {
        XStart: number;
        YStart: number;
        XEnd: number;
        YEnd: number;
      };
      const line: Line = {
        XStart: this.x,
        YStart: this.y,
        XEnd: this.x,
        YEnd: this.y,
      };
      const lineWidth = 1;
      const lineColor = "#ffffff";

      const draw = (lineContext: CanvasRenderingContext2D) => {
        lineContext.beginPath();
        lineContext.moveTo(line.XStart, line.YStart);
        lineContext.lineTo(line.XEnd, line.YEnd);
        lineContext.stroke();
        lineContext.lineWidth = lineWidth;
        lineContext.strokeStyle = lineColor;
        lineContext.closePath();
      };
      const Drawline = gsap.timeline({
        repeat: -1,
        onStart: () => {},
        onUpdate: () => {
          draw(lineContext);
        },
        onComplete: () => {
          //
          // this.bgcontext.globalCompositeOperation = "source-over";
        },
      });
      Drawline.to(line, {
        onUpdate: () => {},
        duration: 1,
        XEnd: to[0],
        YEnd: to[1],
      }).to(line, {
        onStart: () => {},
        onUpdate: () => {
          lineContext.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        },
        duration: 3,
        XStart: to[0],
        YStart: to[1],
      });
    }

    private draw() {
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.outerRadius, 0, 2 * Math.PI);
      this.context.fillStyle = this.color;
      this.context.fill();
      this.context.lineWidth = this.lineWidth;
      this.context.strokeStyle = this.lineColor;
      this.context.closePath();

      this.context.stroke();
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.innerRadius, 0, 2 * Math.PI, true);
      this.context.fillStyle = this.lineColor;
      this.context.fill();
      this.context.closePath();
    }
  }
  const bgparent = document.getElementById(
    "dottodot-line-parent"
  ) as HTMLDivElement; // get the div element
  const canvas = document.getElementById("dottodot") as HTMLCanvasElement;
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  type CircleGridValue = {
    id: [number, number];
    pos: { X: number; Y: number };
    // paused: boolean ;
    // canPause: boolean ;
    instance: Circle | null;
  };

  type Address = { Row: number; Col: number };
  type GridSize = {
    Rows: number;
    Cols: number;
  };
  class CircleGrid {
    private static instance: CircleGrid;
    private grid: Map<string, CircleGridValue>;

    private constructor(
      public readonly rows: number,
      public readonly cols: number,
      public readonly spacing: number
    ) {
      this.grid = new Map();
      this.spacing = spacing;
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          const key = this.getAddressKey(row, col);
          const x = (col + 0.5) * spacing;
          const y = (row + 0.5) * spacing;
          this.grid.set(key, {
            id: [col, row],
            pos: { X: x, Y: y },
            instance: null,
          });
        }
      }
    }

    public static getInstance(
      rows: number,
      cols: number,
      spacing: number
    ): CircleGrid {
      if (!CircleGrid.instance) {
        CircleGrid.instance = new CircleGrid(rows, cols, spacing);
      }
      return CircleGrid.instance;
    }

    public getValue(row: number, col: number): CircleGridValue {
      const key = this.getAddressKey(row, col);
      const gridValue = this.grid.get(key);
      if (!gridValue) {
        throw new Error(`No value found at address: Row ${row}, Col ${col}`);
      }
      return gridValue;
    }

    public setValue(row: number, col: number, value: CircleGridValue): void {
      const key = this.getAddressKey(row, col);
      this.grid.set(key, value);
    }

    public getRandomAddress(): { Row: number; Col: number } {
      const randomRow = Math.floor(Math.random() * this.rows);
      const randomCol = Math.floor(Math.random() * this.cols);
      return { Row: randomRow, Col: randomCol };
    }

    private getAddressKey(row: number, col: number): string {
      return `${row},${col}`;
    }
  }

  function drawCircleGrid(
    bgparent: HTMLDivElement,
    canvas: HTMLCanvasElement,
    spacing: number,
    outerRadius: number,
    innerRadius: number,
    color: string,
    lineWidth: number,
    lineColor: string
  ) {
    const numCols = Math.floor(canvas.width / spacing);
    const numRows = Math.floor(canvas.height / spacing);
    const circleGrid = CircleGrid.getInstance(numRows, numCols, spacing);
    const getRandomExcept = (
      input: number,
      maxlimit: number,
      exclude: number
    ): number => {
      // if (!Number.isInteger(input) || !Number.isInteger(maxlimit) || !Number.isInteger(exclude)) {
      //   throw new Error("Invalid input: all inputs must be integers.");
      // }
      // if (input < 0 || input >= maxlimit || exclude < 0 || exclude >= maxlimit) {
      //   throw new Error("Invalid input: input and exclude must be between 0 and maxlimit-1.");
      // }

      let randNum: number = Math.floor(Math.random() * (maxlimit - 2)) + 1;
      if (randNum >= input) {
        randNum++;
      }
      if (randNum >= exclude) {
        randNum++;
      }

      return randNum;
    };

    function getForwardDiagonalLength(
      rows: number,
      cols: number,
      cellAddress: Address
    ): number {
      const minDimension = Math.min(rows, cols);
      let diagonalLength = 0;

      if (cellAddress.Row <= cellAddress.Col) {
        diagonalLength = Math.min(
          minDimension,
          cols - cellAddress.Col + cellAddress.Row
        );
      } else {
        diagonalLength = Math.min(
          minDimension,
          rows - cellAddress.Row + cellAddress.Col
        );
      }

      return diagonalLength;
    }
    function countBackwardDiagonalElements(
      rows: number,
      cols: number,
      cellAddress: Address
    ): number {
      const minDimension = Math.min(rows, cols);
      let diagonalLength = 0;

      // Determine the length of the diagonal based on the position of the cell within the grid.
      if (cellAddress.Row + cellAddress.Col >= cols) {
        diagonalLength = Math.min(
          minDimension,
          cols - cellAddress.Col + rows - cellAddress.Row
        );
      } else {
        diagonalLength = Math.min(
          minDimension,
          cellAddress.Row + cellAddress.Col + 1
        );
      }

      return diagonalLength;
    }
    function calculateDiagonalCellCol(
      origin: Address,
      gridSize: GridSize,
      diagonalRow: number,
      mode: "Forward" | "Backward"
    ): number {
      const rowDiff = origin.Row - diagonalRow;

      let otherCellCol: number;
      if (mode === "Forward") {
        otherCellCol = origin.Col + rowDiff;
      } else if (mode === "Backward") {
        otherCellCol = origin.Col - rowDiff;
      } else {
        throw new Error(`Invalid mode: ${mode}`);
      }

      if (otherCellCol < 0 || otherCellCol >= gridSize.Cols) {
        console.error(
          "Error: calculated column value is out of bounds",
          otherCellCol,
          gridSize.Rows,
          origin.Row >= gridSize.Rows,
          { origin, diagonalRow }
        );
      }

      return otherCellCol;
    }
    const randomZeroOrOne = () => {
      return Math.round(Math.random());
    };
    const genrateRandomAddress = (range: number, address: Address): Address => {
      const getRandomAddressOnForwordDigonal = (): Address => {
        const newRow = getRandomExcept(
          address.Row,
          Math.min(
            range,
            getForwardDiagonalLength(
              circleGrid.rows,
              circleGrid.cols,
              address
            ) - 1
          ),
          address.Row
        );
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            address,
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            newRow,
            "Forward"
          ),
        };
        return newAddress;
      };
      const getRandomAddressOnBackwordsDigonal = (): Address => {
        const newRow = getRandomExcept(
          address.Row,
          Math.min(
            range,
            countBackwardDiagonalElements(
              circleGrid.rows,
              circleGrid.cols,
              address
            ) - 1
          ),
          address.Row
        );
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            address,
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            newRow,
            "Backward"
          ),
        };
        return newAddress;
      };
      // Generate a random address based on the given range and the current address
      if (randomZeroOrOne()) {
        // perpendicular
        return randomZeroOrOne()
          ? {
              Row: address.Row,
              Col: getRandomExcept(
                address.Col,
                Math.min(range, circleGrid.cols - 1),
                address.Col
              ),
            }
          : {
              Row: getRandomExcept(
                address.Row,
                Math.min(range, circleGrid.rows - 1),
                address.Row
              ),
              Col: address.Col,
            };
      } else {
        return randomZeroOrOne()
          ? getRandomAddressOnForwordDigonal()
          : getRandomAddressOnBackwordsDigonal();
      }
    };

    const generateListOfRandomAddress = (howMany: number, range: number) => {
      const listOfRandomAddress: Address[] = [];
      const firstAddress = circleGrid.getRandomAddress();
      listOfRandomAddress.push(firstAddress);

      const maxAttempts = 100; // set the maximum number of attempts
      let attemptCount = 0; // initialize the counter

      function isCellOutOfBounds(cell: Address, gridSize: GridSize): boolean {
        return (
          cell.Row < 0 ||
          cell.Row >= gridSize.Rows ||
          cell.Col < 0 ||
          cell.Col >= gridSize.Cols
        );
      }

      let validAddressGenerated = false;
      while (listOfRandomAddress.length < howMany) {
        validAddressGenerated = false;
        attemptCount++;
        if (attemptCount === maxAttempts) {
          throw new Error(
            `Failed to generate ${howMany} random addresses within ${maxAttempts} attempts. Maximum attempts reached.`
          );
        }
        const newAddress = genrateRandomAddress(
          range,
          listOfRandomAddress[listOfRandomAddress.length - 1]
        );
        const doesAddressAlreadyExist = listOfRandomAddress.some(
          (addr) => addr.Col === newAddress.Col && addr.Row === newAddress.Row
        );
        const outOfBounds = isCellOutOfBounds(newAddress, {
          Rows: circleGrid.rows,
          Cols: circleGrid.cols,
        });

        if (doesAddressAlreadyExist || outOfBounds) {
          continue;
        }

        validAddressGenerated = true;
        listOfRandomAddress.push(newAddress);
      }

      return listOfRandomAddress;
    };

    // const generateListOfRandomAddress = (howMany: number, range: number) => {
    //   const listOfRandomAddress: Address[] = [];
    //   const firstAddress = { Row: -2, Col: -2 }; //circleGrid.getRandomAddress();
    //   listOfRandomAddress.push(firstAddress);

    //   const maxAttempts = 50; // set the maximum number of attempts

    //   function isCellOutOfBounds(cell: Address, gridSize: GridSize): boolean {
    //     return (
    //       cell.Row < 0 ||
    //       cell.Row >= gridSize.Rows ||
    //       cell.Col < 0 ||
    //       cell.Col >= gridSize.Cols
    //     );
    //   }

    //   for (let attemptCount = 1; attemptCount <= maxAttempts; attemptCount++) {
    //     const newAddress = genrateRandomAddress(
    //       range,
    //       listOfRandomAddress[listOfRandomAddress.length - 1]
    //     );
    //     const doesAddressAlreadyExist = listOfRandomAddress.some(
    //       (addr) => addr.Col === newAddress.Col && addr.Row === newAddress.Row
    //     );
    //     const outOfBounds = isCellOutOfBounds(newAddress, {
    //       Rows: circleGrid.rows,
    //       Cols: circleGrid.cols,
    //     });

    //     if (doesAddressAlreadyExist) {
    //       continue;
    //     }

    //     if (outOfBounds) {
    //       const outOfBoundError = new Error(
    //         `Failed to generate ${howMany} random addresses within ${maxAttempts} attempts. Some generated addresses were out of bounds.`
    //       );
    //       console.error(outOfBoundError, attemptCount);
    //       continue;
    //     }

    //     listOfRandomAddress.push(newAddress);

    //     if (listOfRandomAddress.length === howMany) {
    //       break;
    //     }
    //   }

    //   if (listOfRandomAddress.length < howMany) {
    //     throw new Error(
    //       `Failed to generate ${howMany} random addresses within ${maxAttempts} attempts. Maximum attempts reached.`
    //     );
    //   }

    //   return listOfRandomAddress;
    // };

    const ListOfRandomAddress = generateListOfRandomAddress(12, 6);
    console.log(ListOfRandomAddress, "a");
    if (ListOfRandomAddress === undefined) return;
    ListOfRandomAddress.forEach((Address, i) => {
      console.log(Address, "r", circleGrid.rows, "c", circleGrid.cols);
      const position = circleGrid.getValue(Address.Row, Address.Col).pos;
      const prevCircal = circleGrid.getValue(
        ListOfRandomAddress[i + 1].Row,
        ListOfRandomAddress[i + 1].Col
      );
      const instance = new Circle(
        bgparent,
        canvas,
        position.X,
        position.Y,
        20,
        outerRadius,
        innerRadius,
        color,
        lineWidth,
        lineColor,
        [prevCircal.pos.X, prevCircal.pos.Y]
      );
      circleGrid.setValue(Address.Row, Address.Col, {
        id: [Address.Col, Address.Row],
        pos: {
          X: position.X,
          Y: position.Y,
        },
        instance: instance,
      });
    });

    console.log(circleGrid);
  }

  window.addEventListener("resize", () => {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    const canvases = document.querySelectorAll(".dottodot-background"); // get all canvas elements with the "dottodot-background" class
    canvases.forEach((canvas) => {
      canvas.remove(); // remove each canvas element
    });
    drawCircleGrid(bgparent, canvas, 50, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
  });
  drawCircleGrid(bgparent, canvas, 50, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
</script>
<script></script>
