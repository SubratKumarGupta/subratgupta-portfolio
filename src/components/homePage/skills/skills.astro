---
import DemoThreejs from "./threejs/demoThreejs.astro";
---

<div class="skills">
  <div
    class="text-5xl mobile:text-4xl mobile:h-[30vh] h-[50vh] flex flex-col justify-center"
  >
    <div class="ml-12 mobile:ml-4 text-primary-teal">
      {"${"}<span class="text-white">What can i do</span>{"}"}
    </div>
  </div>
  <div class="h-[100vh]">
    <DemoThreejs />
  </div>
  <div id="dottodot-parent" class="h-[100vh] relative">
    <div id="dottodot-line-parent" class="h-full w-full z-1 absolute"></div>
    <canvas id="dottodot" class="h-full w-full z-5 absolute"></canvas>

    <!-- <canvas id="" class="h-full w-full absolute"> </canvas> -->
  </div>
</div>
<style>
  .dottodot-backgound {
    height: 100%;
    width: 100%;
    background: #000;
    position: absolute;
  }
</style>
<script>
  import gsap from "gsap";

  import type Index from "src/pages/index.astro";
  type CircleGridValue = {
    id: [number, number];
    pos: { X: number; Y: number };
    // paused: boolean ;
    // canPause: boolean ;
    instance: Circle | null;
  };
  type DrawLineOptions = {
    onStart?: () => void;
    onReach?: () => void;
    durationTypeSpeed: boolean;
    duration: number;
    speed: number;
    // onComplete?: () => void;
  };

  type Address = { Row: number; Col: number };
  type GridSize = {
    Rows: number;
    Cols: number;
  };
  function calculateDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): number {
    const xDiff = x2 - x1;
    const yDiff = y2 - y1;
    const distance = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
    return distance;
  }
  class Circle {
    private bgParent: HTMLDivElement;
    private canvas: HTMLCanvasElement;
    private context: CanvasRenderingContext2D;
    public readonly x: number;
    public readonly y: number;
    public readonly outerRadius: number;
    public readonly innerRadius: number;
    public readonly color: string;
    public readonly lineWidth: number;
    public readonly lineColor: string;
    public timeline: gsap.core.Timeline;
    public readonly animateToRadius: number;
    constructor(
      bgParent: HTMLDivElement,
      canvas: HTMLCanvasElement,
      x: number,
      y: number,
      animateToRadius: number,
      outerRadius: number,
      innerRadius: number,
      color: string,
      lineWidth: number,
      lineColor: string

      // to: [number, number]
    ) {
      (this.animateToRadius = animateToRadius), (this.canvas = canvas);
      this.bgParent = bgParent;
      this.context = canvas.getContext("2d")!;
      this.x = x;
      this.y = y;
      this.outerRadius = outerRadius;
      this.innerRadius = innerRadius;
      this.color = color;
      this.lineWidth = lineWidth;
      this.lineColor = lineColor;
      this.timeline = gsap.timeline({
        onStart: () => {
          this.context.clearRect(
            this.x - animateToRadius - this.lineWidth,
            this.y - animateToRadius - this.lineWidth,
            animateToRadius * 2 + this.lineWidth * 2,
            animateToRadius * 2 + this.lineWidth * 2
          );
        },
        onUpdate: () => {
          this.context.clearRect(
            this.x - animateToRadius - lineWidth,
            this.y - animateToRadius - lineWidth,
            animateToRadius * 2 + lineWidth * 2,
            animateToRadius * 2 + lineWidth * 2
          );
          this.draw();
        },
        onComplete: () => {
          // const lineWidth = 20;
          this.context.clearRect(
            this.x - animateToRadius - lineWidth,
            this.y - animateToRadius - lineWidth,
            animateToRadius * 2 + lineWidth * 2,
            animateToRadius * 2 + lineWidth * 2
          );
        },
      });
      this.animate(animateToRadius);
    }
    public RequstShot(from: CircleGridValue, options: DrawLineOptions) {
      if (from.instance === null) {
        throw new Error(`Failed to RequstShot : no instance at ${from.id} `);
      }
      from.instance.drawLineTo([this.x, this.y], {
        onReach: options.onReach,
        onStart: options.onStart,
        durationTypeSpeed: options.durationTypeSpeed,
        duration: options.duration,
        speed: options.speed,
      });
    }
    public shoot(at: CircleGridValue, options: DrawLineOptions) {
      if (at.instance!) {
        throw new Error(`Failed to shoot : no instance at ${at.id}`);
      }
      console.log("sooting at", at);
      this.drawLineTo([at.pos.X, at.pos.Y], {
        onReach: options.onReach,
        onStart: options.onStart,
        durationTypeSpeed: options.durationTypeSpeed,
        duration: options.duration,
        speed: options.speed,
      });
    }
    public GotShot(
      findnext: () => Address | null,
      createCircleInstance: (Address: Address) => void
    ) {
      console.log("ab");
      this.timeline.pause();
      let intervalId: number;
      intervalId = setInterval(() => {
        const creatNext = findnext();
        if (creatNext === null) return;
        createCircleInstance(creatNext);
        this.timeline.resume();
        clearInterval(intervalId);
      }, 1500);
    }
    private animate(to: number) {
      this.timeline
        .to(this, {
          duration: 0.5,
          outerRadius: (50 / 100) * ((75 / 100) * to),
        })
        .to(this, {
          duration: 1,
          outerRadius: (75 / 100) * to,
        })
        .to(this, {
          duration: 1.5,
          outerRadius: to,
          innerRadius: to,
          lineWidth: 3,
        });
    }

    private drawLineTo(to: [number, number], options: DrawLineOptions) {
      const canvas = document.createElement("canvas") as HTMLCanvasElement; // create a new canvas element
      canvas.classList.add("dottodot-background"); // add the "dottodot-background" class to the canvas
      canvas.height = this.canvas.clientHeight; // set the canvas height to 100%
      canvas.width = this.canvas.clientWidth; // set the canvas width to 100%
      canvas.style.position = "absolute";
      // canvas.style.zIndex = "1"; // set the canvas z-index to 5
      this.bgParent.appendChild(canvas); // append the canvas
      const lineContext = canvas.getContext("2d")!;

      type Line = {
        XStart: number;
        YStart: number;
        XEnd: number;
        YEnd: number;
      };

      const line: Line = {
        XStart: this.x,
        YStart: this.y,
        XEnd: this.x,
        YEnd: this.y,
      };
      const dist = calculateDistance(this.x, this.y, to[0], to[1]);
      const lineWidth = 1;
      const lineColor = "#ffffff";
      const speed = options.speed;
      const draw = (lineContext: CanvasRenderingContext2D) => {
        lineContext.beginPath();
        lineContext.moveTo(line.XStart, line.YStart);
        lineContext.lineTo(line.XEnd, line.YEnd);
        lineContext.stroke();
        lineContext.lineWidth = lineWidth;
        lineContext.strokeStyle = lineColor;
        lineContext.closePath();
      };
      const duration = options.durationTypeSpeed
        ? dist / speed
        : options.duration;
      const Drawline = gsap.timeline({
        onStart: () => {
          if (options.onStart) {
            options.onStart();
          }
        },
        onUpdate: () => {
          draw(lineContext);
        },
        onComplete: () => {
          canvas.remove();

          // this.bgcontext.globalCompositeOperation = "source-over";
        },
      });
      Drawline.to(line, {
        onComplete: () => {
          // if (dist !== calculateDistance(line.XStart, line.YStart, to[0], to[1])) {return}
        },
        duration: duration, // dist / speed,
        XEnd: to[0],
        YEnd: to[1],
      }).to(line, {
        onStart: () => {
          if (options.onReach) {
            options.onReach();
          }
        },
        delay: 0.2,
        onUpdate: () => {
          lineContext.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        },
        duration: dist / speed, //,
        XStart: to[0],
        YStart: to[1],
      });
    }
    private draw() {
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.outerRadius, 0, 2 * Math.PI);
      this.context.fillStyle = this.color;
      this.context.fill();
      this.context.lineWidth = this.lineWidth;
      this.context.strokeStyle = this.lineColor;
      this.context.closePath();

      this.context.stroke();
      this.context.beginPath();
      this.context.arc(this.x, this.y, this.innerRadius, 0, 2 * Math.PI, true);
      this.context.fillStyle = this.lineColor;
      this.context.fill();
      this.context.closePath();
    }
  }
  const bgparent = document.getElementById(
    "dottodot-line-parent"
  ) as HTMLDivElement; // get the div element
  const canvas = document.getElementById("dottodot") as HTMLCanvasElement;
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  class CircleGrid {
    private static instance: CircleGrid;
    private grid: Map<string, CircleGridValue>;

    private constructor(
      public readonly rows: number,
      public readonly cols: number,
      public readonly spacing: number
    ) {
      this.grid = new Map();
      this.spacing = spacing;
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          const key = this.getAddressKey(row, col);
          const x = (col + 0.5) * spacing;
          const y = (row + 0.5) * spacing;
          this.grid.set(key, {
            id: [col, row],
            pos: { X: x, Y: y },
            instance: null,
          });
        }
      }
    }

    public static getInstance(
      rows: number,
      cols: number,
      spacing: number
    ): CircleGrid {
      if (!CircleGrid.instance) {
        CircleGrid.instance = new CircleGrid(rows, cols, spacing);
      }
      return CircleGrid.instance;
    }

    public getValue(row: number, col: number): CircleGridValue {
      const key = this.getAddressKey(row, col);
      const gridValue = this.grid.get(key);
      if (!gridValue) {
        throw new Error(`No value found at address: Row ${row}, Col ${col}`);
      }
      return gridValue;
    }

    public setValue(row: number, col: number, value: CircleGridValue): void {
      const key = this.getAddressKey(row, col);
      this.grid.set(key, value);
    }

    public getRandomAddress(): { Row: number; Col: number } {
      const randomRow = Math.floor(Math.random() * this.rows);
      const randomCol = Math.floor(Math.random() * this.cols);
      return { Row: randomRow, Col: randomCol };
    }

    private getAddressKey(row: number, col: number): string {
      return `${row},${col}`;
    }
  }

  function drawCircleGrid(
    bgparent: HTMLDivElement,
    canvas: HTMLCanvasElement,
    spacing: number,
    outerRadius: number,
    innerRadius: number,
    color: string,
    lineWidth: number,
    lineColor: string
  ) {
    const numCols = Math.floor(canvas.width / spacing);
    const numRows = Math.floor(canvas.height / spacing);
    const circleGrid = CircleGrid.getInstance(numRows, numCols, spacing);
    const getRandomExcept = (
      input: number,
      maxlimit: number,
      exclude: number,
      rangePercent: number,
      maxAttempts: number = 50
    ): number => {
      if (!Number.isFinite(rangePercent) || rangePercent < 0) {
        throw new Error(
          "Invalid input: rangePercent must be a number grater than 0 "
        );
      }

      if (maxAttempts < 1) {
        throw new Error(
          "Invalid input: maxAttempts must be a positive integer."
        );
      }
      let range: number;
      if (rangePercent > 1) {
        range = rangePercent;
      } else {
        range = Math.floor(maxlimit * rangePercent);
      }
      const lowerLimit = Math.max(0, input - range);
      const upperLimit = Math.min(maxlimit - 1, input + range);
      const rangeSize = upperLimit - lowerLimit + 1;

      let randNum: number;
      let attempts = 0;
      do {
        randNum = Math.floor(Math.random() * rangeSize) + lowerLimit;
        attempts++;
      } while (
        (randNum === input || randNum === exclude) &&
        attempts < maxAttempts
      );

      if (attempts === maxAttempts) {
        throw new Error(
          `Failed to generate a valid random number after ${maxAttempts} Attempts, input ${input},range ${rangePercent},maxlimit ${maxlimit} .`
        );
      }

      return randNum;
    };

    const getForwardDiagonalLength = (
      rows: number,
      cols: number,
      cellAddress: Address
    ): number => {
      const minDimension = Math.min(rows, cols);
      let diagonalLength = 0;

      if (cellAddress.Row <= cellAddress.Col) {
        diagonalLength = Math.min(
          minDimension,
          cols - cellAddress.Col + cellAddress.Row
        );
      } else {
        diagonalLength = Math.min(
          minDimension,
          rows - cellAddress.Row + cellAddress.Col
        );
      }

      return diagonalLength;
    };
    const getBackwardDiagonalLength = (
      rows: number,
      cols: number,
      cellAddress: Address
    ): number => {
      const minDimension = Math.min(rows, cols);
      let diagonalLength = 0;

      // Determine the length of the diagonal based on the position of the cell within the grid.
      if (cellAddress.Row + cellAddress.Col >= cols) {
        diagonalLength = Math.min(
          minDimension,
          cols - cellAddress.Col + rows - cellAddress.Row
        );
      } else {
        diagonalLength = Math.min(
          minDimension,
          cellAddress.Row + cellAddress.Col + 1
        );
      }

      return diagonalLength;
    };
    const calculateDiagonalCellCol = (
      origin: Address,
      gridSize: GridSize,
      diagonalRow: number,
      mode: "Forward" | "Backward"
    ): number => {
      if (
        !origin ||
        typeof origin.Row !== "number" ||
        typeof origin.Col !== "number"
      ) {
        throw new Error("Invalid origin address");
      }
      if (
        origin.Row < 0 ||
        origin.Row >= gridSize.Rows ||
        origin.Col < 0 ||
        origin.Col >= gridSize.Cols
      ) {
        throw new Error("Invalid origin address: out of bounds");
      }

      if (
        !gridSize ||
        typeof gridSize.Rows !== "number" ||
        typeof gridSize.Cols !== "number"
      ) {
        throw new Error("Invalid grid size");
      }

      if (
        typeof diagonalRow !== "number" ||
        diagonalRow < 0 ||
        diagonalRow >= gridSize.Rows
      ) {
        throw new Error("Invalid diagonal row index");
      }

      if (mode !== "Forward" && mode !== "Backward") {
        throw new Error("Invalid mode");
      }

      const rowDiff = origin.Row - diagonalRow;

      let otherCellCol: number;
      if (mode === "Forward") {
        otherCellCol = origin.Col - rowDiff;
      } else if (mode === "Backward") {
        otherCellCol = origin.Col + rowDiff;
      } else {
        throw new Error(`Invalid mode: ${mode}`);
      }

      if (otherCellCol < 0 || otherCellCol >= gridSize.Cols) {
        console.error(
          "Error: calculated column value is out of bounds",
          otherCellCol,
          gridSize.Rows,
          origin.Row >= gridSize.Rows,
          { origin, diagonalRow }
        );
      }

      return otherCellCol;
    };
    const randomZeroOrOne = () => {
      return Math.round(Math.random());
    };
    const randNum = (min: number, max: number) => {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    const genrateRandomAddress = (range: number, address: Address): Address => {
      const getRandomAddressOnForwordDigonal = (): Address => {
        const newRow = getRandomExcept(
          address.Row,
          getForwardDiagonalLength(circleGrid.rows, circleGrid.cols, address) -
            1,
          address.Row,
          range
        );
        console.log("a");
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            address,
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            newRow,
            "Forward"
          ),
        };
        return newAddress;
      };
      const getRandomAddressOnBackwordsDigonal = (): Address => {
        const newRow = getRandomExcept(
          address.Row,
          getBackwardDiagonalLength(circleGrid.rows, circleGrid.cols, address) -
            1,
          address.Row,
          range
        );
        const newAddress: Address = {
          Row: newRow,
          Col: calculateDiagonalCellCol(
            address,
            { Rows: circleGrid.rows, Cols: circleGrid.cols },
            newRow,
            "Backward"
          ),
        };
        return newAddress;
      };
      // Generate a random address based on the given range and the current address

      // perpendicular
      if (randomZeroOrOne()) {
        return randomZeroOrOne()
          ? {
              Row: address.Row,
              Col: getRandomExcept(
                address.Col,
                circleGrid.cols, //Math.min(500, ),
                address.Col,
                range
              ),
            }
          : {
              Row: getRandomExcept(
                address.Row,
                circleGrid.rows, //Math.min(500, circleGrid.rows - 1),
                address.Row,
                range
              ),
              Col: address.Col,
            };
      } else {
        return randomZeroOrOne()
          ? getRandomAddressOnForwordDigonal()
          : getRandomAddressOnBackwordsDigonal();
      }
    };
    const createCircleInstance = (
      bgparent: HTMLDivElement,
      canvas: HTMLCanvasElement,
      position: { X: number; Y: number }
    ) => {
      return new Circle(
        bgparent,
        canvas,
        position.X,
        position.Y,
        randNum(15, 25),
        outerRadius,
        innerRadius,
        color,
        lineWidth,
        lineColor
      );
    };
    const createCircleGridValue = (
      CircleAddress: Address,
      listOfAddress: readonly Address[],
      afterCreation:
        | ((
            createdCircleInstance: Circle,
            address: Address,
            listOfAddress: readonly Address[]
          ) => void)
        | null
    ) => {
      const position = circleGrid.getValue(
        CircleAddress.Row,
        CircleAddress.Col
      ).pos;
      const CircleInstance = createCircleInstance(bgparent, canvas, position);
      circleGrid.setValue(CircleAddress.Row, CircleAddress.Col, {
        id: [CircleAddress.Col, CircleAddress.Row],
        pos: position,
        instance: CircleInstance,
      });
      const gridValue = circleGrid.getValue(
        CircleAddress.Row,
        CircleAddress.Col
      );

      if (gridValue.instance === null) {
        throw new Error(
          `failed to create a circle on ${gridValue} at ${gridValue.id}`
        );
      }
      {
        console.log(`created circle at${gridValue.id} `);
      }

      if (afterCreation) {
        (() => {
          if (gridValue.instance)
            afterCreation(gridValue.instance, CircleAddress, listOfAddress);
        })();
      }
      // return
    };
    const generateListOfRandomAddress = (
      howMany: number,
      range: number,
      firstAddress: Address
    ) => {
      const listOfRandomAddress: Address[] = [];

      listOfRandomAddress.push(firstAddress);

      const maxAttempts = 100; // set the maximum number of attempts
      let attemptCount = 0; // initialize the counter
      console.log("max");
      function isCellOutOfBounds(cell: Address, gridSize: GridSize): boolean {
        return (
          cell.Row < 0 ||
          cell.Row >= gridSize.Rows ||
          cell.Col < 0 ||
          cell.Col >= gridSize.Cols
        );
      }

      let validAddressGenerated = false;
      while (listOfRandomAddress.length < howMany) {
        validAddressGenerated = false;
        attemptCount++;
        if (attemptCount === maxAttempts) {
          const a = {
            fr: listOfRandomAddress[0].Row,
            fc: listOfRandomAddress[0].Col,
            lr: listOfRandomAddress[listOfRandomAddress.length - 1].Row,
            lc: listOfRandomAddress[listOfRandomAddress.length - 1].Col,
          };
          throw new Error(
            `Failed to generate ${howMany} random addresses within ${maxAttempts} attempts. Maximum attempts reached current array is ${[
              a.fc,
              a.fc,
              a.lr,
              a.lc,
            ]}.`
          );
        }
        const newAddress = genrateRandomAddress(
          range,
          listOfRandomAddress[listOfRandomAddress.length - 1]
        );
        const doesAddressAlreadyExist = listOfRandomAddress.some(
          (addr) => addr.Col === newAddress.Col && addr.Row === newAddress.Row
        );
        const outOfBounds = isCellOutOfBounds(newAddress, {
          Rows: circleGrid.rows,
          Cols: circleGrid.cols,
        });
        if (doesAddressAlreadyExist || outOfBounds) {
          continue;
        }

        const doseInstancAlreadyExist = (() => {
          const value = circleGrid.getValue(newAddress.Row, newAddress.Col);
          if (value.instance instanceof Circle) {
            return true;
          }
          return false;
        })();
        if (doseInstancAlreadyExist) continue;

        validAddressGenerated = true;
        listOfRandomAddress.push(newAddress);
      }

      return listOfRandomAddress;
    };

    function findNearestCircleInRange(
      range: number,
      address: Address,
      circleGrid: CircleGrid
    ): CircleGridValue | null {
      const { rows, cols } = circleGrid;

      // Check if the given address is within the grid
      if (
        address.Row < 0 ||
        address.Row >= rows ||
        address.Col < 0 ||
        address.Col >= cols
      ) {
        return null;
      }

      // Check the neighboring cells for a circle within range
      for (let i = -range; i <= range; i++) {
        for (let j = -range; j <= range; j++) {
          // Skip the current cell (i=0, j=0)
          if (i === 0 && j === 0) {
            continue;
          }

          // Check if the neighboring cell is within the grid
          const row = address.Row + i;
          const col = address.Col + j;
          if (row < 0 || row >= rows || col < 0 || col >= cols) {
            continue;
          }

          // Check if the neighboring cell has a Circle instance and is within range
          const neighbor = circleGrid.getValue(row, col);
          if (
            !(neighbor.instance instanceof Circle) ||
            Math.abs(i) > range ||
            Math.abs(j) > range
          ) {
            continue;
          }

          // Check if the neighboring cell is diagonal or perpendicular to the given cell
          if ((i !== 0 && j !== 0) || i !== 0 || j !== 0) {
            return circleGrid.getValue(row, col);
            // return { Row: row, Col: col };
          }
        }
      }

      // No neighboring circle within range found
      return null;
    }

    const ListOfRandomAddress = generateListOfRandomAddress(
      12,
      3,
      circleGrid.getRandomAddress()
    );
    console.log(ListOfRandomAddress, "a");
    const createInitialCircles = (AddressList: readonly Address[]) => {
      const seedCircleAddress = AddressList[0];
      let createdCircles = 0;
      const recursiveCreateInitalCircles = (Address: Address) => {
        console.log(createdCircles);
        if (createdCircles === AddressList.length) return;
        createCircleGridValue(
          Address,
          AddressList,
          (createdCircle, _, AddressList) => {
            createdCircles++;
            //for last circle in the list
            if (createdCircles === AddressList.length) return;
            if (AddressList === undefined) return;

            const nextAddress = AddressList[createdCircles];
            createdCircle.shoot(
              circleGrid.getValue(nextAddress.Row, nextAddress.Col),
              {
                onReach: () => {
                  console.log("abbbb", createdCircles);
                  recursiveCreateInitalCircles(nextAddress);
                  const newCreatedCircle = circleGrid.getValue(
                    nextAddress.Row,
                    nextAddress.Col
                  ).instance;
                  console.log(newCreatedCircle, "aut");
                  if (newCreatedCircle === null) return;
                  setTimeout(() => {
                    newCreatedCircle.GotShot(
                      () => {
                        try {
                          return generateListOfRandomAddress(
                            0,
                            3,
                            nextAddress
                          )[0];
                        } catch (error) {
                          console.log("brok");
                          return null;
                        }
                      },
                      (address) => {
                        const recursiveCreateCircles = (address: Address) => {
                          createCircleGridValue(
                            address,
                            [address],
                            (createdCircle) => {
                              const NextAddress = generateListOfRandomAddress(
                                3,
                                3,
                                address
                              )[1];
                              const nextCircle = circleGrid.getValue(
                                NextAddress.Row,
                                NextAddress.Col
                              );
                              createdCircle.shoot(nextCircle, {
                                onReach: () => {
                                  recursiveCreateCircles(NextAddress);
                                  setTimeout(() => {
                                    if (nextCircle.instance === null) return;
                                    nextCircle.instance.GotShot(
                                      () => {
                                        try {
                                          return generateListOfRandomAddress(
                                            3,
                                            3,
                                            address
                                          )[1];
                                        } catch (error) {
                                          console.log("brok");
                                          return null;
                                        }
                                      },
                                      (newaddress) => {
                                        console.log("a0a0a");
                                        recursiveCreateCircles(newaddress);
                                      }
                                    );
                                  }, 5000);
                                },
                                speed: 100,
                                duration: 1,
                                durationTypeSpeed: true,
                                onStart: () => {},
                              });
                            }
                          );
                        };
                        recursiveCreateCircles(address);
                      }
                    );
                  }, 1500);
                },
                speed: 300,
                duration: 0.4,
                durationTypeSpeed: false,
                onStart: () => {},
              }
            );
          }
        );
      };
      recursiveCreateInitalCircles(seedCircleAddress);
    };
    //split array in tow
    const firstHalf = ListOfRandomAddress.slice(
      0,
      Math.floor(ListOfRandomAddress.length / 2)
    );
    const secondHalf = ListOfRandomAddress.slice(
      Math.floor(ListOfRandomAddress.length / 2)
    );
    //draw array seprately
    createInitialCircles(firstHalf);
    createInitialCircles(secondHalf);
    // seedCircleInstance
    // ListOfRandomAddress.forEach((Address, i) => { // remove this
    //   console.log(Address, "r", circleGrid.rows, "c", circleGrid.cols);
    //   const position = circleGrid.getValue(Address.Row, Address.Col).pos;
    //   const prevCircal = circleGrid.getValue(
    //     ListOfRandomAddress[i + 1].Row,
    //     ListOfRandomAddress[i + 1].Col
    //   );
    //   const instance = new Circle(
    //     bgparent,
    //     canvas,
    //     position.X,
    //     position.Y,
    //     20,
    //     outerRadius,
    //     innerRadius,
    //     color,
    //     lineWidth,
    //     lineColor,
    //     300,
    //     [prevCircal.pos.X, prevCircal.pos.Y]
    //   );
    //   circleGrid.setValue(Address.Row, Address.Col, {
    //     id: [Address.Col, Address.Row],
    //     pos: {
    //       X: position.X,
    //       Y: position.Y,
    //     },
    //     instance: instance,
    //   });
    // });

    console.log(circleGrid);
  }

  window.addEventListener("resize", () => {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    const canvases = document.querySelectorAll(".dottodot-background"); // get all canvas elements with the "dottodot-background" class
    canvases.forEach((canvas) => {
      canvas.remove(); // remove each canvas element
    });
    drawCircleGrid(bgparent, canvas, 60, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
  });
  drawCircleGrid(bgparent, canvas, 60, 0, 0, "#3fd4d4", 10, "rgb(14 18 18)");
</script>
<script></script>

<!-- given an  2d grid  with value type CircleGridValue = {
  id: [number, number];
  pos: { X: number; Y: number };
  // paused: boolean ;
  // canPause: boolean ;
  instance: Circle | null;
};  write a function in typescript that takes in a range value 'range', size of grid as type GridSize = {
  Rows: number;
  Cols: number;
}; , an address of a cell on the grid as 
type Address = { Row: number; Col: number }; and finds address of a grid -->
